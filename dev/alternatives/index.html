<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Alternatives · TrackedArray.jl</title><meta name="title" content="Alternatives · TrackedArray.jl"/><meta property="og:title" content="Alternatives · TrackedArray.jl"/><meta property="twitter:title" content="Alternatives · TrackedArray.jl"/><meta name="description" content="Documentation for TrackedArray.jl."/><meta property="og:description" content="Documentation for TrackedArray.jl."/><meta property="twitter:description" content="Documentation for TrackedArray.jl."/><meta property="og:url" content="https://adolgert.github.io/TrackedArray.jl/alternatives/"/><meta property="twitter:url" content="https://adolgert.github.io/TrackedArray.jl/alternatives/"/><link rel="canonical" href="https://adolgert.github.io/TrackedArray.jl/alternatives/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TrackedArray.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../implements/">Implementations</a></li><li class="is-active"><a class="tocitem" href>Alternatives</a><ul class="internal"><li><a class="tocitem" href="#Goals"><span>Goals</span></a></li><li><a class="tocitem" href="#History"><span>History</span></a></li><li><a class="tocitem" href="#Current-Limitations"><span>Current Limitations</span></a></li><li><a class="tocitem" href="#Alternative-Approaches"><span>Alternative Approaches</span></a></li><li><a class="tocitem" href="#Fundamental-Trade-offs"><span>Fundamental Trade-offs</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Alternatives</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Alternatives</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adolgert/TrackedArray.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adolgert/TrackedArray.jl/blob/main/docs/src/alternatives.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Alternative-Approaches-for-Dynamic-Dependency-Tracking"><a class="docs-heading-anchor" href="#Alternative-Approaches-for-Dynamic-Dependency-Tracking">Alternative Approaches for Dynamic Dependency Tracking</a><a id="Alternative-Approaches-for-Dynamic-Dependency-Tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-Approaches-for-Dynamic-Dependency-Tracking" title="Permalink"></a></h1><h2 id="Goals"><a class="docs-heading-anchor" href="#Goals">Goals</a><a id="Goals-1"></a><a class="docs-heading-anchor-permalink" href="#Goals" title="Permalink"></a></h2><p>TrackedArray.jl aims to enable efficient continuous-time simulation by automatically discovering dependencies between events and state variables. The core requirements are:</p><ul><li><strong>Dynamic dependency discovery</strong>: Events declare dependencies through actual data access patterns, not pre-wired graphs</li><li><strong>Fine-grained tracking</strong>: Track reads/writes at the individual field level within mutable structs</li><li><strong>Container flexibility</strong>: Support vectors and dictionaries of both mutable and immutable objects</li><li><strong>Runtime efficiency</strong>: Minimal overhead during simulation execution</li><li><strong>Container resizing</strong>: Handle dynamic addition/removal of elements</li></ul><h2 id="History"><a class="docs-heading-anchor" href="#History">History</a><a id="History-1"></a><a class="docs-heading-anchor-permalink" href="#History" title="Permalink"></a></h2><p><strong>Generalized Stochastic Petri Nets (GSPN)</strong> represented the first generation of dependency-aware simulation. GSPNs required explicit dependency graphs between Places and Transitions, making simulation logic clear but requiring complex upfront &quot;wiring.&quot; This approach scaled poorly and obscured simulation choices within graph topology.</p><p><strong>Rule-based simulation engines</strong> emerged as the second generation, using declarative logic systems (Datalog, Prolog, production rules) to automatically infer dependencies. Rules like <code>enabled(T) :- place(P), marking(P,N), N&gt;0, depends(T,P)</code> promised automatic dependency discovery, but suffered from:</p><ul><li>Heavy external dependencies on rule engines</li><li>Performance overhead from rule evaluation</li><li>Poor integration with host languages</li><li>Limited expressiveness for continuous-time stochastic processes</li></ul><p><strong>TrackedArray.jl</strong> represents a third-generation approach: automatic dependency discovery through execution tracing in the host language, avoiding both explicit wiring and external rule engines.</p><h2 id="Current-Limitations"><a class="docs-heading-anchor" href="#Current-Limitations">Current Limitations</a><a id="Current-Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Current-Limitations" title="Permalink"></a></h2><p>Analysis of existing TrackedArray.jl implementations reveals fundamental architectural constraints:</p><p><strong>Container Rigidity</strong>: All implementations assume fixed-size containers at construction. Vector resizing (<code>push!</code>, <code>pop!</code>, <code>deleteat!</code>) breaks index-based tracking systems, and dictionary key addition/removal is not properly supported.</p><p><strong>Intrusive Data Structures</strong>: Elements must contain path information (container indices, keys) to enable tracking. This creates tight coupling between elements and their containers, preventing reuse across different container types.</p><p><strong>Mixed Object Type Limitations</strong>: Current focus on mutable struct field modifications provides no mechanism for tracking immutable object replacement within containers.</p><p><strong>Memory Efficiency</strong>: Benchmark data shows 10-20x performance degradation in some approaches (Doubles: 286K+ allocations, Dealer: 475MB memory usage) due to per-element tracking overhead.</p><h2 id="Alternative-Approaches"><a class="docs-heading-anchor" href="#Alternative-Approaches">Alternative Approaches</a><a id="Alternative-Approaches-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-Approaches" title="Permalink"></a></h2><h3 id="Function-Instrumentation"><a class="docs-heading-anchor" href="#Function-Instrumentation">Function Instrumentation</a><a id="Function-Instrumentation-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Instrumentation" title="Permalink"></a></h3><p><strong>Cassette.jl/IRTools.jl Approach</strong>: Transform <code>fire!</code> functions to inject tracking calls around state access operations.</p><pre><code class="language-julia hljs">Cassette.@context TrackingCtx
function Cassette.overdub(ctx::TrackingCtx, ::typeof(getproperty), obj, field)
    record_read!(ctx.metadata, obj, field)
    Cassette.fallback(ctx, getproperty, obj, field)
end</code></pre><p><strong>Advantages</strong>: Non-intrusive data structures, automatic dependency discovery, works with arbitrary access patterns.</p><p><strong>Critical Limitation</strong>: Multi-step access operations (<code>physical.agents[5].age += 1</code>) require tracking through complex call chains. The three-step operation (getproperty → getindex → getproperty/setproperty!) necessitates instrumenting every function that might be called, creating a transitive closure problem. Compound operators (<code>+=</code>, <code>*=</code>), broadcast operations, and function call boundaries exponentially increase instrumentation complexity.</p><h3 id="Proxy/View-Based-Tracking"><a class="docs-heading-anchor" href="#Proxy/View-Based-Tracking">Proxy/View-Based Tracking</a><a id="Proxy/View-Based-Tracking-1"></a><a class="docs-heading-anchor-permalink" href="#Proxy/View-Based-Tracking" title="Permalink"></a></h3><p><strong>Path-Carrying Proxies</strong>: Return enriched objects that know their location in the state hierarchy.</p><pre><code class="language-julia hljs">struct ElementProxy{T}
    element::T
    path::Tuple{Symbol, Int}  # (:agents, 5)
end

# Usage: physical.agents[5] returns ElementProxy, not raw element</code></pre><p><strong>Advantages</strong>: Non-intrusive elements, automatic path construction, precise tracking without instrumentation complexity.</p><p><strong>Disadvantages</strong>: Significant memory overhead (every access creates proxy objects), type system complexity (all operations must handle proxy types), poor ergonomics (users see proxy types instead of raw values).</p><h3 id="Ultra-Efficient-Storage"><a class="docs-heading-anchor" href="#Ultra-Efficient-Storage">Ultra-Efficient Storage</a><a id="Ultra-Efficient-Storage-1"></a><a class="docs-heading-anchor-permalink" href="#Ultra-Efficient-Storage" title="Permalink"></a></h3><p><strong>Dense Bitset Tracking</strong>: Store changed/read state as packed bits for maximum efficiency.</p><pre><code class="language-julia hljs">struct UltraTracker{N}
    changed_bits::NTuple{N, UInt64}  # Stack-allocated bit arrays
    read_bits::NTuple{N, UInt64}
end

# 8 bytes per 64 PlaceKeys, branchless bit manipulation
@inline mark_changed!(t, id) = set_bit!(t.changed_bits, id)</code></pre><p><strong>Performance Characteristics</strong>: 1-2 CPU cycles per tracking operation, zero allocations, cache-friendly sequential operations.</p><p><strong>Requirement</strong>: PlaceKeys must map to dense integers, determined at compile-time or through perfect hashing schemes.</p><h3 id="Macro-Based-Access-Transformation"><a class="docs-heading-anchor" href="#Macro-Based-Access-Transformation">Macro-Based Access Transformation</a><a id="Macro-Based-Access-Transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Macro-Based-Access-Transformation" title="Permalink"></a></h3><p><strong>Syntactic Transformation</strong>: Transform access expressions into explicit tracking + access pairs.</p><pre><code class="language-julia hljs">@track physical physical.agents[5].age += 1
# Expands to:
# record_read!(physical.tracker, AGENTS_5_AGE)
# record_write!(physical.tracker, AGENTS_5_AGE) 
# physical.agents[5].age += 1</code></pre><p><strong>Fundamental Limitation</strong>: <strong>Data flow analysis problem</strong>. Macros operate at syntax level but dependency tracking requires semantic analysis:</p><pre><code class="language-julia hljs">velocity = physical.agents[i].velocity    # Tracked: (:agents, i, :velocity)
physical.agents[j].position += velocity   # CANNOT track: velocity dependency lost</code></pre><p>Intermediate variables, control flow, function boundaries, and aliasing make comprehensive tracking impossible through pure syntactic transformation.</p><h3 id="Copy-on-Write-Persistent-Structures"><a class="docs-heading-anchor" href="#Copy-on-Write-Persistent-Structures">Copy-on-Write Persistent Structures</a><a id="Copy-on-Write-Persistent-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Copy-on-Write-Persistent-Structures" title="Permalink"></a></h3><p><strong>Structural Sharing</strong>: Avoid mutation entirely, track changes through persistent data structure modifications.</p><p><strong>Disadvantages</strong>: High memory overhead, doesn&#39;t align with simulation patterns requiring in-place updates, poor performance for frequent small modifications.</p><h2 id="Fundamental-Trade-offs"><a class="docs-heading-anchor" href="#Fundamental-Trade-offs">Fundamental Trade-offs</a><a id="Fundamental-Trade-offs-1"></a><a class="docs-heading-anchor-permalink" href="#Fundamental-Trade-offs" title="Permalink"></a></h2><p>The analysis reveals three core tensions:</p><p><strong>Expressiveness vs. Efficiency</strong>: More flexible data structures require more complex tracking mechanisms. Ultra-efficient approaches (bitsets, intrusive tracking) constrain user expressiveness.</p><p><strong>Non-intrusion vs. Performance</strong>: Approaches that avoid modifying user data structures (instrumentation, proxies) incur significant runtime overhead or implementation complexity.</p><p><strong>Static vs. Dynamic Analysis</strong>: Compile-time optimization opportunities (macro transformation, dense PlaceKey mapping) are limited by runtime data flow patterns that cannot be statically determined.</p><p><strong>The Core Dilemma</strong>: Precise dependency tracking fundamentally requires either intrusive data structures OR comprehensive program analysis. The current TrackedArray.jl approach chooses intrusion for performance, accepting constraints on flexibility and composability.</p><p>No approach eliminates all limitations - each represents a different point in the design space trading off performance, flexibility, and implementation complexity.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../implements/">« Implementations</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Wednesday 2 July 2025 11:35">Wednesday 2 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
