var documenterSearchIndex = {"docs":
[{"location":"implements/#TrackedArray.jl-Implementations","page":"Implementations","title":"TrackedArray.jl Implementations","text":"","category":"section"},{"location":"implements/#Interface","page":"Implementations","title":"Interface","text":"","category":"section"},{"location":"implements/","page":"Implementations","title":"Implementations","text":"TrackedArray.jl provides a common interface for tracking reads and writes to arrays of mutable structs. The core interface consists of:","category":"page"},{"location":"implements/#Creating-a-PhysicalState","page":"Implementations","title":"Creating a PhysicalState","text":"","category":"section"},{"location":"implements/","page":"Implementations","title":"Implementations","text":"physical = ConstructState(specification, counts)","category":"page"},{"location":"implements/#Accessing-Values","page":"Implementations","title":"Accessing Values","text":"","category":"section"},{"location":"implements/","page":"Implementations","title":"Implementations","text":"Read: getproperty(getitem(getproperty(physical, :arraysymbol), index), :member)\nWrite: setproperty!(getitem(getproperty(physical, :arraysymbol), index), :member, value)","category":"page"},{"location":"implements/#Tracking-Interface","page":"Implementations","title":"Tracking Interface","text":"","category":"section"},{"location":"implements/","page":"Implementations","title":"Implementations","text":"changed(physical) - Returns an iterable of PlaceKey tuples (array_symbol, index, member_symbol) that were written\nwasread(physical) - Returns an iterable of PlaceKey tuples that were read\naccept(physical) - Clears memory of writes and reads\nresetread(physical) - Clears only read memory","category":"page"},{"location":"implements/#Benchmark-Summary","page":"Implementations","title":"Benchmark Summary","text":"","category":"section"},{"location":"implements/","page":"Implementations","title":"Implementations","text":"Performance comparison from git hash b464082 on 2025-07-02:","category":"page"},{"location":"implements/","page":"Implementations","title":"Implementations","text":"Implementation Small Random Writes Small All Writes Large Random Writes Large All Writes Notes\nObserved 0.17ms 4.13ms 0.28ms 46.76ms Best overall performance\nSecondary 0.16ms 3.27ms 0.28ms 45.55ms Fastest, uses BitVectors\nOriginal 0.58ms 6.05ms 1.69ms 68.28ms Baseline implementation\nShared 0.18ms 3.92ms 0.30ms 50.41ms Shared tracker approach\nDoubles 2.04ms 8.00ms 15.42ms 129.50ms Per-field bit tracking\nDealer 0.52ms 12.96ms 0.60ms 103.68ms High memory usage","category":"page"},{"location":"implements/","page":"Implementations","title":"Implementations","text":"Memory usage ranges from ~160KB (best) to ~8MB (worst) for small tests, and from ~140KB to ~470MB for large tests.","category":"page"},{"location":"implements/#Implementation-History","page":"Implementations","title":"Implementation History","text":"","category":"section"},{"location":"implements/","page":"Implementations","title":"Implementations","text":"src/tracked.jl (2025-06-28 06:55:07) - Original implementation using Set-based tracking in each element with @tracked_struct macro and container back-references.\nsrc/observed.jl (2025-06-28 10:58:44) - Notification-based system where elements notify their container vectors, which notify a centralized physical state using Vector storage.\nsrc/doubles.jl (2025-06-28 11:22:15) - Bit-field approach storing read/write bits directly in each struct field using field_name_track integers with bitwise operations.\nsrc/dealer.jl (2025-06-28 11:47:37) - Immutable functional approach using TrackingState with Dict storage, TrackedElement wrappers, and structural sharing.\nsrc/secondary.jl (2025-06-28 12:23:56) - \"Arithmetic Registry\" model using pre-allocated BitVectors and arithmetic calculations to map element field access to bit indices.\nsrc/shared.jl (2025-06-29 07:28:44) - Shared tracker approach using Cuddle wrappers that encapsulate data with path information and a shared Tracker{T} instance.\nsrc/contain.jl (2025-06-30 08:25:25) - Hybrid combining Shared and Observed concepts with Cuddle wrappers using function pointers instead of direct tracker references.\nsrc/contain_optimized.jl (2025-06-30 08:32:02) - Optimized version of Contain eliminating closure allocations by storing tracker directly in CuddleOpt structs.\nsrc/thirdparty.jl (2025-06-30 08:49:09) - Enhanced Observed-style implementation with typed tracker references and improved type safety in ObservedVector{T,TK}.","category":"page"},{"location":"alternatives/#Alternative-Approaches-for-Dynamic-Dependency-Tracking","page":"Alternatives","title":"Alternative Approaches for Dynamic Dependency Tracking","text":"","category":"section"},{"location":"alternatives/#Goals","page":"Alternatives","title":"Goals","text":"","category":"section"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"TrackedArray.jl aims to enable efficient continuous-time simulation by automatically discovering dependencies between events and state variables. The core requirements are:","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Dynamic dependency discovery: Events declare dependencies through actual data access patterns, not pre-wired graphs\nFine-grained tracking: Track reads/writes at the individual field level within mutable structs\nContainer flexibility: Support vectors and dictionaries of both mutable and immutable objects\nRuntime efficiency: Minimal overhead during simulation execution\nContainer resizing: Handle dynamic addition/removal of elements","category":"page"},{"location":"alternatives/#History","page":"Alternatives","title":"History","text":"","category":"section"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Generalized Stochastic Petri Nets (GSPN) represented the first generation of dependency-aware simulation. GSPNs required explicit dependency graphs between Places and Transitions, making simulation logic clear but requiring complex upfront \"wiring.\" This approach scaled poorly and obscured simulation choices within graph topology.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Rule-based simulation engines emerged as the second generation, using declarative logic systems (Datalog, Prolog, production rules) to automatically infer dependencies. Rules like enabled(T) :- place(P), marking(P,N), N>0, depends(T,P) promised automatic dependency discovery, but suffered from:","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Heavy external dependencies on rule engines\nPerformance overhead from rule evaluation\nPoor integration with host languages\nLimited expressiveness for continuous-time stochastic processes","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"TrackedArray.jl represents a third-generation approach: automatic dependency discovery through execution tracing in the host language, avoiding both explicit wiring and external rule engines.","category":"page"},{"location":"alternatives/#Current-Limitations","page":"Alternatives","title":"Current Limitations","text":"","category":"section"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Analysis of existing TrackedArray.jl implementations reveals fundamental architectural constraints:","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Container Rigidity: All implementations assume fixed-size containers at construction. Vector resizing (push!, pop!, deleteat!) breaks index-based tracking systems, and dictionary key addition/removal is not properly supported.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Intrusive Data Structures: Elements must contain path information (container indices, keys) to enable tracking. This creates tight coupling between elements and their containers, preventing reuse across different container types.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Mixed Object Type Limitations: Current focus on mutable struct field modifications provides no mechanism for tracking immutable object replacement within containers.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Memory Efficiency: Benchmark data shows 10-20x performance degradation in some approaches (Doubles: 286K+ allocations, Dealer: 475MB memory usage) due to per-element tracking overhead.","category":"page"},{"location":"alternatives/#Alternative-Approaches","page":"Alternatives","title":"Alternative Approaches","text":"","category":"section"},{"location":"alternatives/#Function-Instrumentation","page":"Alternatives","title":"Function Instrumentation","text":"","category":"section"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Cassette.jl/IRTools.jl Approach: Transform fire! functions to inject tracking calls around state access operations.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Cassette.@context TrackingCtx\nfunction Cassette.overdub(ctx::TrackingCtx, ::typeof(getproperty), obj, field)\n    record_read!(ctx.metadata, obj, field)\n    Cassette.fallback(ctx, getproperty, obj, field)\nend","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Advantages: Non-intrusive data structures, automatic dependency discovery, works with arbitrary access patterns.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Critical Limitation: Multi-step access operations (physical.agents[5].age += 1) require tracking through complex call chains. The three-step operation (getproperty → getindex → getproperty/setproperty!) necessitates instrumenting every function that might be called, creating a transitive closure problem. Compound operators (+=, *=), broadcast operations, and function call boundaries exponentially increase instrumentation complexity.","category":"page"},{"location":"alternatives/#Proxy/View-Based-Tracking","page":"Alternatives","title":"Proxy/View-Based Tracking","text":"","category":"section"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Path-Carrying Proxies: Return enriched objects that know their location in the state hierarchy.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"struct ElementProxy{T}\n    element::T\n    path::Tuple{Symbol, Int}  # (:agents, 5)\nend\n\n# Usage: physical.agents[5] returns ElementProxy, not raw element","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Advantages: Non-intrusive elements, automatic path construction, precise tracking without instrumentation complexity.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Disadvantages: Significant memory overhead (every access creates proxy objects), type system complexity (all operations must handle proxy types), poor ergonomics (users see proxy types instead of raw values).","category":"page"},{"location":"alternatives/#Ultra-Efficient-Storage","page":"Alternatives","title":"Ultra-Efficient Storage","text":"","category":"section"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Dense Bitset Tracking: Store changed/read state as packed bits for maximum efficiency.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"struct UltraTracker{N}\n    changed_bits::NTuple{N, UInt64}  # Stack-allocated bit arrays\n    read_bits::NTuple{N, UInt64}\nend\n\n# 8 bytes per 64 PlaceKeys, branchless bit manipulation\n@inline mark_changed!(t, id) = set_bit!(t.changed_bits, id)","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Performance Characteristics: 1-2 CPU cycles per tracking operation, zero allocations, cache-friendly sequential operations.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Requirement: PlaceKeys must map to dense integers, determined at compile-time or through perfect hashing schemes.","category":"page"},{"location":"alternatives/#Macro-Based-Access-Transformation","page":"Alternatives","title":"Macro-Based Access Transformation","text":"","category":"section"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Syntactic Transformation: Transform access expressions into explicit tracking + access pairs.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"@track physical physical.agents[5].age += 1\n# Expands to:\n# record_read!(physical.tracker, AGENTS_5_AGE)\n# record_write!(physical.tracker, AGENTS_5_AGE) \n# physical.agents[5].age += 1","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Fundamental Limitation: Data flow analysis problem. Macros operate at syntax level but dependency tracking requires semantic analysis:","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"velocity = physical.agents[i].velocity    # Tracked: (:agents, i, :velocity)\nphysical.agents[j].position += velocity   # CANNOT track: velocity dependency lost","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Intermediate variables, control flow, function boundaries, and aliasing make comprehensive tracking impossible through pure syntactic transformation.","category":"page"},{"location":"alternatives/#Copy-on-Write-Persistent-Structures","page":"Alternatives","title":"Copy-on-Write Persistent Structures","text":"","category":"section"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Structural Sharing: Avoid mutation entirely, track changes through persistent data structure modifications.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Disadvantages: High memory overhead, doesn't align with simulation patterns requiring in-place updates, poor performance for frequent small modifications.","category":"page"},{"location":"alternatives/#Fundamental-Trade-offs","page":"Alternatives","title":"Fundamental Trade-offs","text":"","category":"section"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"The analysis reveals three core tensions:","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Expressiveness vs. Efficiency: More flexible data structures require more complex tracking mechanisms. Ultra-efficient approaches (bitsets, intrusive tracking) constrain user expressiveness.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Non-intrusion vs. Performance: Approaches that avoid modifying user data structures (instrumentation, proxies) incur significant runtime overhead or implementation complexity.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"Static vs. Dynamic Analysis: Compile-time optimization opportunities (macro transformation, dense PlaceKey mapping) are limited by runtime data flow patterns that cannot be statically determined.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"The Core Dilemma: Precise dependency tracking fundamentally requires either intrusive data structures OR comprehensive program analysis. The current TrackedArray.jl approach chooses intrusion for performance, accepting constraints on flexibility and composability.","category":"page"},{"location":"alternatives/","page":"Alternatives","title":"Alternatives","text":"No approach eliminates all limitations - each represents a different point in the design space trading off performance, flexibility, and implementation complexity.","category":"page"},{"location":"#TrackedArray","page":"Home","title":"TrackedArray","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TrackedArray.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides multiple implementations for tracking reads and writes to arrays of mutable structs, enabling automatic dependency discovery for continuous-time simulation.","category":"page"}]
}
